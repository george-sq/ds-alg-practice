# 常用数据排序算法

---

## 排序评估

1. **时间复杂度**: 排序算法的耗时估计；
2. **空间复杂度(原地排序)**: 排序算法的内存估计；原地排序的空间复杂度为$O(1)$；
3. **排序稳定性**: 相同的数据元素，在排序前后是否保留原有的前后位置顺序；

## 排序方法对比

![常用排序对比](../resources/images/ "常用排序对比")

---

## 冒泡排序

**时间复杂度**: $O(n^2)$ 

**排序思想**：迭代比较

**排序步骤**:

1. 从前往后遍历待排数据元素序列(序列长度为n)的同时，对相邻数据元素进行两两对比；
2. 根据相邻元素的对比结果，将较大(较小)的数据元素，置于相邻元素的靠后位置；
3. 每完成一次(i次)序列遍历，使得待数据序列的`最大值(最小值)`位于序列的末尾元素；
4. 忽律已排序的末尾元素，获得新的待排数据元素序列，`n=n-i`;
5. 重复step1~step4，直到`新的待排数据元素序列长度为1`，排序完成；

**排序特点**:

- 稳定排序
- 原地排序

---

## 插入排序

**时间复杂度**: $O(n^2)$ 

**排序思想**：分区比较

**排序步骤**: 

1. 将待排数据序列，划分**有序区间** 和 **无序区间**；
2. 将待排数据序列的`第一个元素`作为**有序区间**，`剩下的待排数据元素`作为**无序区间**；
3. 遍历**无序区间**中数据元素的同时，并与**有序区间**的数据元素进行`从后往前的对比`；
4. ***对比交换条件***：`无序元素A` **小于** 被比较的 `有序元素X`；
5. 根据数据元素的对比结果，将**无序区间**中`数据元素A`，插入到**有序区间**中`大于`数据元素A的`最小值之前`；若**有序区间**中，***没有大于数据元素A的值***，则将数据元素A扩展为**有序区间** 的`末尾位置`；
6. 重复***step3~4***，直到**无序区间**的数据元素为空，排序完成；

**排序特点**:

- 稳定排序
- 原地排序

---

## 选择排序

**时间复杂度**: $O(n^2)$ 

**排序思想**：分区+比较+选择

**排序步骤**:

1. 将待排数据序列，划分**有序区间** 和 **无序区间**；
2. 选择**无序区间** 中***最小值元素***，插入**无序区间** 的 ***末尾位置***；
3. 重复***step2*** ，直到**有序区间** 元素为1；

**排序特点**:

- 非稳定排序
- 原地排序

---

## 归并排序

**时间复杂度**: $O(nlogn)$ 

**排序思想**：分治比较(分组+递归+比较/合并)，采用递归技巧实现；

**排序步骤**:

1. **分组**：将待排序数组*划分成* **两个数据数组**，对分组后的数据数组分别*递归调用(递归开始)*算法本身，直到***每组数据元素个数为1***；
2. **递归结束条件**：`分组后，待排序数组的元素个数为1` ；
3. 申请**临时数组temp**，*长度*为需要合并的**两个数据元素数组的元素数目之和**；
4. **比较/合并**：从前往后迭代对比两个分组的*首元素*，将*数据值较小的元素*插入**临时数组temp**末尾，并*将该数据元素从原分组数组中删除*，直到*两个分组数组的元素*都插入到**临时数组temp**中；若某一*数据数组A*的元素*已全部插入*到临时数组temp(为空)，另一*数据数组B*还有*剩余元素*时，*将数组B的剩余元素全部插入到临时数组末尾即可*；
5. 将*数据元素有序*的**临时数组temp** 作为*嵌套递归调用的返回值*；
6. 返回*上层递归逻辑* ，**重复step2~3** ，直到返回**最上层的递归逻辑** ，获得`最上层合并后的临时数组temp` ；
7. 排序结束，**排序结果**为`最上层合并后的临时数组temp` ；

**排序特点**:

- 稳定排序
- 非原地排序

---

## 快速排序

**时间复杂度**: $O(nlogn)$ 

**排序思想**：分治比较(分组+比较/移动+递归)

**排序步骤**:

1. **分组**：从待排序数组中选择一个*中间索引下标* ，并将该索引下标的元素作为**分区元素(分区点)** ，将待排序数组*分组为* 两个**新的待排序数组(左/右侧数组)** ；
2. **比较** ：迭代**左/右侧数组的元素** ，并分别与 **分区元素** 比较；
3. **移动** ：将*大于*  **分区元素** 的数组元素，移动到分区元素的**右侧分组数组** ，将*小于* **分区元素** 的数组元素，移动到分区元素的**左侧分组数组** ；
4. **递归调用**：对**左/右侧分组数组** 分别执行算法本身的*递归调用(递归开始)* ，直到***左/右侧分组数组的元素个数为1*** ；
5. **递归结束条件**：`分组后，待排序数组的元素个数为1`；
6. 递归结束，排序结束；

 **排序特点**:

- 非稳定排序
- 原地排序

---

## 桶排序

**时间复杂度**: $O(n)$ 

**排序思想**：分桶+快排

**排序步骤**:

1. 根据待排序数据，选择**适合的有序分桶**，*保证数据元素能够均匀分布在各个桶内* ；
2. 对每个桶内的数据元素，进行**快速排序**；
3. 按桶的顺序，组合桶内已排序数据；

**排序特点**:

- 数据能够均匀分桶
- 适用于外部排序
- 稳定排序

---

## 计数排序

**时间复杂度**: $O(n)$ 

**排序思想**：计数

**排序步骤**:

1. xxx

**排序特点**:

- 稳定排序

---

## 基数排序

**时间复杂度**: $O(n)$ 

**排序思想**：寻找公共基数

**排序步骤**:

1. xxx

**排序特点**:

- 稳定排序

    

---
